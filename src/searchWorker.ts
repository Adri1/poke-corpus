import 'compression-streams-polyfill';

export interface SearchParams {
  query: string,
  regex: boolean,
  caseInsensitive: boolean,
  common: boolean,
  script: boolean,
  collections: string[],
  languages: string[]
};

export interface SearchTask {
  index: number,
  params: SearchParams,
  collectionKey: string,
  fileKey: string,
  languages: string[]
}

export type SearchTaskResultError = 'error' | 'regex' | 'network';
export type SearchTaskResultDone = 'done';
export type SearchTaskResultStatus = 'loading' | 'processing' | SearchTaskResultDone | SearchTaskResultError;
export interface SearchTaskResultLines {
  collection: string,
  file: string,
  languages: string[],
  lines: string[][]
}
export interface SearchTaskResult {
  index: number,
  status: SearchTaskResultStatus,
  result?: SearchTaskResultLines
}
export interface SearchTaskResultComplete {
  index: number,
  status: SearchTaskResultDone,
  result: SearchTaskResultLines
}

export const cacheVersion = "v1";

/* eslint-disable no-restricted-globals */
self.onmessage = (task: MessageEvent<SearchTask>) => {
  //#region Helper functions
  /**
   * Attempts the following, in order:
   * - Retrieving the file from the cache
   * - Populating the cache with the file
   * - Fetching the file directly
   *
   * Returns a promise of the text of the file.
   */
  const getFileFromCache = (collectionKey: string, languageKey: string, fileKey: string) => {
    const url = process.env.PUBLIC_URL + `/corpus/${collectionKey}/${languageKey}_${fileKey}.txt.gz`;
    return caches.open(cacheVersion)
    .then((cache) => cache.match(url).then(res => res
      ?? cache.add(url).then(() => cache.match(url)).then(res => res
        ?? fetch(url))))
    .catch(() => fetch(url))
    .catch((err) => {
      console.error(err);
      notify('network');
      return null;
    })
    .then((res) => res === null ? '' :
      res.blob().then((blob) => new Response(blob.stream().pipeThrough(new DecompressionStream('gzip'))).text()))
    .then(preprocessString);
  }

  // SMUSUM Chinese Pok√©mon names
  const chineseChars = 'ËõãÂ¶ôËõôÁßçÂ≠êËçâËä±Â∞èÁÅ´ÈæôÊÅêÂñ∑Êù∞Â∞ºÈæüÂç°Âí™Ê∞¥ÁÆ≠ÁªøÊØõËô´ÈìÅÁî≤ËõπÂ∑¥Â§ßËù∂Áã¨ËßíÂ£≥ÈíàËúÇÊ≥¢ÊØîÈ∏üÊãâËææÁÉàÈõÄÂò¥ÈòøÊüèËõáÊÄ™ÁöÆ‰∏òÈõ∑Á©øÂ±±Èº†ÁéãÂ§öÂÖ∞Â®úÂêéÊúóÂäõËØ∫ÂèØË•øÂÖ≠Â∞æ‰πùËÉñ‰∏ÅË∂ÖÈü≥Ëù†Ëµ∞Ë∑ØËá≠Èú∏Ê¥æÊñØÁâπÁêÉÊë©È≤ÅËõæÂú∞‰∏âÂñµÁå´ËÄÅÈ∏≠Âì•Áå¥Êö¥ËíÇÁãóÈ£éÈÄüËöäÈ¶ôËùåËö™ÂêõÊ≥≥Â£´ÂáØÂãáÂü∫ËÉ°ËÖïË±™ÂñáÂè≠ËäΩÂè£ÂëÜÈ£üÁéõÁëôÊØçÊØíÂà∫Êã≥Áü≥ÈöÜÂ≤©È©¨ÁÑ∞ÂÖΩÁ£ÅÂêà‰∏ÄËë±ÂòüÂà©Êµ∑ÁãÆÁôΩÊ≥•ËàåË¥ùÈ¨ºÈÄöËÄøÂÇ¨Áú†Ë≤òÂºïÊ¢¶‰∫∫Èí≥ËüπÂ∑®ÈúπÈõ≥ÁîµÈ°ΩÂºπÊ§∞Ê†ëÂòéÂï¶È£ûËÖøÈÉéÂø´Â§¥Áì¶ÂèåÁäÄÁâõÈíªÂêâËîìËó§Ë¢ãÂ¢®ÈáëÈ±ºÊòüÂÆùÈ≠îÂ¢ôÂÅ∂Â§©Ëû≥ËûÇËø∑ÂîáÂßêÂáªÁΩóËÇØÊ≥∞È≤§ÊôÆÁôæÂèò‰ºäÂ∏ÉËæπËèäÂåñÁõîÈï∞ÂàÄÁøºÊÄ•ÂÜªÈó™‰Ω†ÂìàÂÖãÂπªÂè∂ÊúàÊ°ÇÁ´∫ËëµÈîØÈ≥ÑËìùÁ´ãÂíïÂ§úÈπ∞Ëä≠Áì¢ÂÆâÂúÜ‰∏ùËõõÂèâÂ≠óÁÅØÁ¨ºÂè§ÁÑ∂Âí©ÁæäËå∏Áæé‰∏ΩÈú≤ÊâçÁöáÊØΩÊ£âÈïøÊâãÂêëÊó•ËúªËúì‰πåÊ≤ºÂ§™Èò≥‰∫ÆÈªëÊöóÈ∏¶Â¶ñÊú™Áü•ÂõæËÖæÊûúÁøÅÈ∫íÈ∫üÂ•áÊ¶õ‰ΩõÊâòÂúüÂºüËùéÈí¢ÂçÉÂ£∂Ëµ´ÁãÉÁÜäÂúàÁÜîËúóÁå™ÁèäÁëöÁÇÆÁ´†Ê°∂‰ø°‰ΩøÁøÖÊà¥Âä†Ë±°È°ø‚Ö°ÊÉäÈπøÁä¨Êó†ÁïèÊàòËàûÂ®ÉÂ•∂ÁΩêÂπ∏Á¶èÂÖ¨ÁÇéÂ∏ùÂπºÊ≤ôÁè≠Ê¥õ‰∫öÂá§Êó∂Êú®ÂÆàÂÆ´Ê£ÆÊûóËú•Ëú¥Á®öÈ∏°Â£ÆË∑ÉÁãºÁ∫πÁõ¥ÂÜ≤ËåßÁã©ÁåéÁõæÁ≤âËé≤Á´•Â∏Ω‰πêÊ≤≥Ê©°ÂÆûÈºªÁã°ÁåæÂÇ≤È™®ÁáïÈ∏•ËéâÂ•àÊúµÊ∫úÁ≥ñÈõ®ËòëËèáÊñóÁ¨†ÊáíÁç≠ËøáÂä®ÁåøËØ∑ÂÅáÂ±ÖÂøçÈù¢ËÄÖËÑ±Â¶ûÂêºÁàÜÂπï‰∏ãÊéåÊúùÂåó‰ºòÈõÖÂãæÈ≠ÇÁúºÈÇ£ÊÅ∞ÂßÜËêΩÊ≠£ÊãçË¥üËê§ÁîúËî∑ËñáÊ∫∂ÂêûÁâôÈ≤®È≤∏È©ºÁÖ§ÁÇ≠Ë∑≥ÂôóÊôÉÊñëÈ¢öËöÅÊº†‰ªôÊ≠åÈùíÁªµ‰∏ÉÂ§ïÈº¨Êñ©È•≠ÂåôÈ≥ÖÈ≤∂ËôæÂÖµËûØÁß§ÂøµËß¶ÊëáÁØÆÁæΩ‰∏ëÁ∫≥È£òÊµÆÊ≥°ÈöêÊÄ®ÂΩ±ËØÖÂííÂ∑°ÁÅµÂΩ∑Âæ®ÁÉ≠Â∏¶ÈìÉÂãÉÊ¢≠Èõ™ÂÜ∞Êä§Ë±πÁèçÁè†Ê®±Á©∫Ê£òÁà±ÂøÉÂìëÂ±ûËâæÊ¨ßÁõñÂõ∫ÂùêÁ•à‰ª£Â∏åËãóÂè∞ÁåõÊõºÊãøÂÑøÁã∏Ê≥ïÂ∏àÁÆ±ËüÄÂãí‰º¶Áê¥Âê´ÁæûËãûÊßåÂüéÁªìË¥µÂ¶áÁªÖËúúÂ•≥Â∏ïÂÖπÊΩúÂÖîÈöèÂç∑ËÄ≥È≠Ö‰∏úÊñΩÈìõÂìçÂù¶ÈìúÈïúÈíüÁõÜËÅíÂô™ÈôÜÂ∞ñÂí¨‰∏çËâØÈ™∑ËçßÂÖâÈúìËôπËá™ËàîÁãÇËøúÔº∫Áî±Âç¢Â∏≠ÊÅ©È™ëËâ≤ÈúèËé±Ë∞¢Á±≥Â∞îÂÆôÊèê‰∏ªÊöñÁÇíÊ≠¶ÂàÉ‰∏∏ÂâëÊé¢Ê≠•Âì®Á∫¶ÊâíÈÖ∑ÂÜ∑ËöÄË±ÜÈ∏ΩÈ´òÈõâÂπîÂ∫ûÊªöËùôËû∫ÈíâÂ∑ÆÊê¨ËøêÂå†‰øÆÂª∫ËüæËúçÊäïÊëîÊâìÂåÖ‰øùË∂≥ËúàËö£ËΩ¶ËΩÆÁ≤æÊ†πË£ôÈáéËõÆÈ≤àÊ∑∑ÊµÅÊ∞ìÁ∫¢ÂÄíÁãíÊÆøÊªëÂ∑æÂæÅÂì≠ÂÖ∑Ê≠ªÁ•ûÊ£∫ÂéüËÇãÂßãÁ•ñÁ†¥ÁÅ∞Â∞òÁ¥¢Ê≤´Ê†óÂæ∑ÂçïÂçµÁªÜËÉûÈÄ†ÈπÖÂÄçÂõõÂ≠£ËêåÂìéÂëÄË¥•ËΩªËúòÂùöÈΩøÁªÑÈ∫ªÈ≥óÂÆáÁÉõÂπΩÊô∂ÊñßÂöèÂá†‰ΩïÊïèÊç∑ÂäüÂ§´Áà∂Ëµ§È©πÂäàÂè∏‰ª§ÁÇ∏ÈõÑÁßÉ‰∏´È¶ñÊÅ∂ÁáÉÁÉßÊØï‰∫ëÈÖãËø™ËÄ∂Â°îËµõÈáåÁãêÂë±Ë¥∫ÊéòÂΩ©ËììÊ¥ÅËÉΩÈûòËä≥ËäôÂ¶ÆÂ•ΩÈ±øË¥ºËÑöÈì†ÂûÉËóªËáÇÊû™‰ºûÂíöÁ¢éÈªèÈí•ÊúΩÂçóÁìúÂó°Âì≤Ë£¥Ê†ºÊû≠ÁãôÂ∞ÑÁÇΩÂíÜÂìÆËôéÊºæÂ£¨Á¨ÉÂïÑÈì≥Â∞ëÂº∫ÈîπÂÜúËÉúËôªÈ¨ÉÂº±ÂùèÈ©¥‰ªîÈáçÊåΩÊª¥‰º™Áù°ÁΩ©ÁõóÁùÄÁ´πÁñóÁéØÊô∫Êå•Áå©Êé∑ËÉÜÂô¨Â†°Áà∑ÂèÇÊÄßÔºöÈì∂‰º¥Èô®ÊûïÊààË∞úÊãüÔº±Á£®ËàµÈ≥ûÊùñÁíû„ÉªÈ∏£ÂìûÈ≥çÁßëËé´Ëø¶ËôöÂêæËÇåË¥πÊùüËæâÁ∫∏Âæ°Êú∫Â§èËõãÂ¶ôËõôÁ®ÆÂ≠êËçâËä±Â∞èÁÅ´ÈæçÊÅêÂô¥ÂÇëÂ∞ºÈæúÂç°Âí™Ê∞¥ÁÆ≠Á∂†ÊØõËü≤ÈêµÁî≤ËõπÂ∑¥Â§ßËù∂Áç®ËßíÊÆºÈáùËúÇÊ≥¢ÊØîÈ≥•ÊãâÈÅîÁÉàÈõÄÂò¥ÈòøÊüèËõáÊÄ™ÁöÆ‰∏òÈõ∑Á©øÂ±±Èº†ÁéãÂ§öËò≠Â®úÂêéÊúóÂäõË´æÂèØË•øÂÖ≠Â∞æ‰πùËÉñ‰∏ÅË∂ÖÈü≥Ëù†Ëµ∞Ë∑ØËá≠Èú∏Ê¥æÊñØÁâπÁêÉÊë©È≠ØËõæÂú∞‰∏âÂñµË≤ìËÄÅÈ¥®Âì•Áå¥ÁàÜËíÇÁãóÈ¢®ÈÄüËöäÈ¶ôËùåËö™ÂêõÊ≥≥Â£´Âá±ÂãáÂü∫ËÉ°ËÖïË±™ÂñáÂè≠ËäΩÂè£ÂëÜÈ£üÁë™ÁëôÊØçÊØíÂà∫Êã≥Áü≥ÈöÜÂ≤©È¶¨ÁÑ∞Áç∏Á£ÅÂêà‰∏ÄËî•ÂòüÂà©Êµ∑ÁçÖÁôΩÊ≥•ËàåË≤ùÈ¨ºÈÄöËÄøÂÇ¨Áú†Ë≤òÂºïÂ§¢‰∫∫ÈâóËüπÂ∑®ÈúπÈùÇÈõªÈ†ëÂΩàÊ§∞Ê®πÂòéÂï¶È£õËÖøÈÉéÂø´È†≠Áì¶ÈõôÁäÄÁâõÈëΩÂêâËîìËó§Ë¢ãÂ¢®ÈáëÈ≠öÊòüÂØ∂È≠îÁâÜÂÅ∂Â§©Ëû≥ËûÇËø∑ÂîáÂßêÊìäÁæÖËÇØÊ≥∞ÈØâÊö¥ÊôÆÁôæËÆä‰ºäÂ∏ÉÈÇäËèäÂåñÁõîÈêÆÂàÄÁøºÊÄ•ÂáçÈñÉ‰Ω†ÂìàÂÖãÂπªËëâÊúàÊ°ÇÁ´∫ËëµÈã∏È±∑ËóçÁ´ãÂíïÂ§úÈ∑πËä≠Áì¢ÂÆâÂúìÁµ≤ËõõÂèâÂ≠óÁáàÁ±†Âè§ÁÑ∂Âí©ÁæäËå∏ÁæéÈ∫óÈú≤ÊâçÁöáÊØΩÊ£âÈï∑ÊâãÂêëÊó•ËúªËúìÁÉèÊ≤ºÂ§™ÈôΩ‰∫ÆÈªëÊöóÈ¥âÂ¶ñÊú™Áü•ÂúñÈ®∞ÊûúÁøÅÈ∫íÈ∫üÂ•áÊ¶õ‰ΩõÊâòÂúüÂºüË†çÈãºÂçÉÂ£∫Ëµ´ÁãÉÁÜäÂúàÁÜîËù∏Ë±¨ÁèäÁëöÁÇÆÁ´†Ê°∂‰ø°‰ΩøÁøÖÊà¥Âä†Ë±°È†ì‚Ö°È©öÈπøÁä¨ÁÑ°ÁïèÊà∞ËàûÂ®ÉÂ•∂ÁΩêÂπ∏Á¶èÂÖ¨ÁÇéÂ∏ùÂπºÊ≤ôÁè≠Ê¥õ‰∫ûÈ≥≥ÊôÇÊú®ÂÆàÂÆÆÊ£ÆÊûóËú•Ëú¥Á®öÈõûÂ£ØË∫çÁãºÁ¥ãÁõ¥Ë°ùÁπ≠Áã©ÁçµÁõæÁ≤âËìÆÁ´•Â∏ΩÊ®ÇÊ≤≥Ê©°ÂØ¶ÈºªÁã°ÁåæÂÇ≤È™®ÁáïÈ∑óËéâÂ•àÊúµÊ∫úÁ≥ñÈõ®ËòëËèáÊñóÁ¨†Êá∂Áç∫ÈÅéÂãïÁåøË´ãÂÅáÂ±ÖÂøçÈù¢ËÄÖËÑ´Â¶ûÂêºÂπï‰∏ãÊéåÊúùÂåóÂÑ™ÈõÖÂãæÈ≠ÇÁúºÈÇ£ÊÅ∞ÂßÜËêΩÊ≠£ÊãçË≤†Ëû¢ÁîúËñîËñáÊ∫∂ÂêûÁâôÈØäÈØ®ÈßùÁÖ§ÁÇ≠Ë∑≥ÂôóÊôÉÊñëÈ°éËüªÊº†‰ªôÊ≠åÈùíÁ∂ø‰∏ÉÂ§ïÈº¨Êñ¨È£ØÂåôÈ∞çÈØ∞Ëù¶ÂÖµËûØÁß§ÂøµËß∏ÊêñÁ±ÉÁæΩÈÜúÁ¥çÈ£ÑÊµÆÊ≥°Èö±ÊÄ®ÂΩ±Ë©õÂííÂ∑°ÈùàÂΩ∑Âæ®ÁÜ±Â∏∂Èà¥ÂãÉÊ¢≠Èõ™ÂÜ∞Ë≠∑Ë±πÁèçÁè†Ê´ªÁ©∫Ê£òÊÑõÂøÉÂïûÂ±¨ËâæÊ≠êËìãÂõ∫ÂùêÁ•à‰ª£Â∏åËãóÂè∞ÁåõÊõºÊãøÂÖíÁã∏Ê≥ïÂ∏´ÁÆ±ËüÄÂãíÂÄ´Áê¥Âê´ÁæûËãûÊßåÂüéÁµêË≤¥Â©¶Á¥≥ËúúÂ•≥Â∏ïËå≤ÊΩõÂÖîÈö®Êç≤ËÄ≥È≠ÖÊù±ÊñΩÈê∫ÈüøÂù¶ÈäÖÈè°ÈêòÁõÜËÅíÂô™Èô∏Â∞ñÂí¨‰∏çËâØÈ™∑ÂÖâÈúìËôπËá™ËàîÁãÇÈÅ†Ôº∫Áî±ÁõßÂ∏≠ÊÅ©È®éËâ≤ÈúèËêäË¨ùÁ±≥ÁàæÂÆôÊèê‰∏ªÊöñÁÇíÊ≠¶ÂàÉ‰∏∏ÂäçÊé¢Ê≠•Âì®Á¥ÑÊâíÈÖ∑ÂÜ∑ËùïË±ÜÈ¥øÈ´òÈõâÂπîÈæêÊªæËùôËû∫ÈáòÂ∑ÆÊê¨ÈÅãÂå†‰øÆÂª∫ËüæËúçÊäïÊëîÊâìÂåÖ‰øùË∂≥ËúàËö£ËªäËº™ÊØ¨Á≤æÊ†πË£ôÈáéË†ªÈ±∏Ê∑∑ÊµÅÊ∞ìÁ¥ÖÂÄíÁãíÊÆøÊªëÂ∑æÂæµÂì≠ÂÖ∑Ê≠ªÁ•ûÊ£∫ÂéüËÇãÂßãÁ•ñÁ†¥ÁÅ∞Â°µÁ¥¢Ê≤´Ê†óÂæ∑ÂñÆÂçµÁ¥∞ËÉûÈÄ†ÈµùÂÄçÂõõÂ≠£ËêåÂìéÂëÄÊïóËºïËúòÂ†ÖÈΩíÁµÑÈ∫ªÈ∞ªÂÆáÁá≠ÂπΩÊô∂ÊñßÂöèÂπæ‰ΩïÊïèÊç∑ÂäüÂ§´Áà∂Ëµ§ÈßíÂäàÂè∏‰ª§ÁÇ∏ÈõÑÁ¶ø‰∏´È¶ñÊÉ°ÁáÉÁáíÁï¢Èõ≤ÈÖãËø™ËÄ∂Â°îË≥ΩÈáåÁãêÂë±Ë≥ÄÊéòÂΩ©ËììÊΩîËÉΩÈûòËä≥ËäôÂ¶ÆÂ•ΩÈ≠∑Ë≥äËÖ≥ÈéßÂûÉËóªËáÇÊßçÂÇòÂíöÁ¢éÈªèÈë∞ÊúΩÂçóÁìúÂó°Âì≤Ë£¥Ê†ºÊ¢üÁãôÂ∞ÑÁÜæÂíÜÂìÆËôéÊºæÂ£¨ÁØ§ÂïÑÈäÉÂ∞ëÂº∑Èç¨Ëæ≤ÂãùËôªÈ¨ÉÂº±Â£ûÈ©¢‰ªîÈáçÊåΩÊª¥ÂÅΩÁù°ÁΩ©ÁõúËëóÁ´πÁôÇÁí∞Êô∫ÊèÆÁå©Êì≤ËÜΩÂô¨Â†°Áà∫ÂèÉÊÄßÔºöÈäÄ‰º¥ÈöïÊûïÊààË¨éÊì¨Ôº±Á£®ËàµÈ±óÊùñÁíû„ÉªÈ≥¥ÂìûÈ∞≠ÁßëËé´Ëø¶ËôõÂêæËÇåË≤ªÊùüËºùÁ¥ôÂæ°Ê©üÂ§èÂûíÁ£äÁ†∞Â••Â£òÁ£äÁ†∞‰∏ëÂ•ß';
  const remapChineseChars = (s: string) => {
    return s.search(/[\uE800-\uEE26]/u) === -1 ? s : (
      Array.from(s).map((c) => {
        const codePoint = c.codePointAt(0);
        return (codePoint !== undefined && codePoint >= 0xE800 && codePoint <= 0xEE26) ? chineseChars[codePoint - 0xE800] : c;
      }).join('')
    );
  }

  // ORAS Korean Braille
  const remapKoreanBraille = (s: string) => {
    return s.search(/[\u1100-\u11FF\uE0C0-\uE0C7]/u) === -1 ? s : (s
      .replaceAll('\uE0C0', 'Í∑∏ÎûòÏÑú') // geuraeseo
      .replaceAll('\uE0C1', 'Í∑∏Îü¨ÎÇò') // geureona
      .replaceAll('\uE0C2', 'Í∑∏Îü¨Î©¥') // geureomyeon
      .replaceAll('\uE0C3', 'Í∑∏Îü¨ÎØÄÎ°ú') // geureomeuro
      .replaceAll('\uE0C4', 'Í∑∏Îü∞Îç∞') // geureonde
      .replaceAll('\uE0C5', 'Í∑∏') // UNUSED go
      .replaceAll('\uE0C6', 'Í∑∏Î¶¨ÌïòÏó¨') // geurihayeo
      .replaceAll('·Ü®·Ö©', 'Í∑∏Î¶¨Í≥†') // geurigeo
      .replaceAll('\uE0C7·Ñâ', '·Ñä') // ss
      .replaceAll('\uE0C7·ÑÄ', '·ÑÅ') // kk
      .replaceAll('\uE0C7·ÑÉ', '·ÑÑ') // tt
      .replaceAll('\uE0C7·Ñá', '·Ñà') // pp
      .replaceAll('\uE0C7·Ñå', '·Ñç') // jj
      .replaceAll('\uE0C7', '·Ñâ') // unmatched double consonant
      .replaceAll(/([\u1100-\u115F])([ÏñµÏòπÏö∏Ïò•Ïó∞Ïö¥Ïò®Ïñ∏ÏñºÏó¥Ïù∏ÏòÅÏùÑÏùÄ])/gu, (_, initial: string, syllable: string) => initial + syllable.normalize("NFD").substring(1)) // combine initial with abbreviations
      .replaceAll(/([Í∞ÄÎÇòÎã§ÎßàÎ∞îÏÇ¨ÏûêÏπ¥ÌÉÄÌååÌïò])([\u11A8-\u11FF])/gu, (_, syllable: string, final: string) => syllable.normalize("NFD") + final) // combine abbreviations with final
      .replaceAll(/^[\u1160-\u1175]+$/gum, (match) => '\u115F' + match.split('').join('\u115F')) // filler for unmatched vowels in strings of unmatched vowels
      .replaceAll(/(?<![\u1100-\u115F])([\u1160-\u1175])/gu, '·Ñã$1') // add null initial to all other unmatched vowels
      .replaceAll(/([\u1100-\u115F])(?![\u1160-\u1175]|$)/gum, '$1\u1160') // filler for unmatched initials
      .replaceAll(/(?<![\u1160-\u1175])([\u11A8-\u11FF])/gum, '\u115F\u1160$1') // filler for unmatched finals
      .normalize()
    );
  }

  // NDS special characters
  const remapNDSSpecialCharacters = (s: string) => {
    return s.search(/[\u2460-\u2487]/u) === -1 ? s : (s
      .replaceAll('\u2469', '·µâ ≥') // Gen 5 superscript er
      .replaceAll('\u246A', ' ≥·µâ') // Gen 5 superscript re
      .replaceAll('\u246B', ' ≥') // Gen 5 superscript r
      .replaceAll('\u2485', '·µâ') // Gen 5 superscript e
    );
  }

  // 3DS special characters
  const remap3DSSpecialCharacters = (s: string) => {
    return remapChineseChars(remapKoreanBraille(
      s.search(/[\uE000-\uE0A8]/u) === -1 ? s : (s
        // System
        .replaceAll('\uE000', '‚í∂') // A Button
        .replaceAll('\uE001', '‚í∑') // B Button
        .replaceAll('\uE002', '‚ìç') // X Button
        .replaceAll('\uE003', '‚ìé') // Y Button
        .replaceAll('\uE004', '‚ìÅ') // L Button
        .replaceAll('\uE005', '‚ìá') // R Button
        .replaceAll('\uE006', '‚úú') // Control Pad
        .replaceAll('\uE073', 'üè†Ô∏é') // Home Button

        // Pok√©mon private use
        .replaceAll('\uE08A', '·µâ ≥') // Superscript er
        .replaceAll('\uE08B', ' ≥·µâ') // Superscript re
        .replaceAll('\uE08C', ' ≥') // Superscript r
        .replaceAll('\uE092', '‚ô•') // Halfwidth eighth note
        .replaceAll('\uE09A', '‚ô™') // Halfwidth eighth note
        .replaceAll('\uE0A6', '·µâ') // Superscript e

        // ORAS Braille
        .replaceAll('\uE081', '.') // French period (dots-256) [UNUSED]
        .replaceAll('\uE082', ',') // French comma (dots-2) [UNUSED]
        .replaceAll('\uE083', '.') // Italian period (dots-256) [UNUSED]
        .replaceAll('\uE084', ',') // Italian comma (dots-2) [UNUSED]
        .replaceAll('\uE085', '.') // German period (dots-3)
        .replaceAll('\uE086', ',') // German comma (dots-2) [UNUSED]
        .replaceAll('\uE087', '.') // Spanish period (dots-3)
        .replaceAll('\uE088', ',') // Spanish comma (dots-2) [UNUSED]
      )
    ));
  }

  // Switch special characters
  const remapSwitchSpecialCharacters = (s: string) => {
    return s.search(/[\uE300-\uE31C]/u) === -1 ? s : (s
      .replaceAll('\uE300', '$') // Pok√©mon Dollar
      .replaceAll('\uE301', 'A') // Unown A
      .replaceAll('\uE302', 'B') // Unown B
      .replaceAll('\uE303', 'C') // Unown C
      .replaceAll('\uE304', 'D') // Unown D
      .replaceAll('\uE305', 'E') // Unown E
      .replaceAll('\uE306', 'F') // Unown F
      .replaceAll('\uE307', 'G') // Unown G
      .replaceAll('\uE308', 'H') // Unown H
      .replaceAll('\uE309', 'I') // Unown I
      .replaceAll('\uE30A', 'J') // Unown J
      .replaceAll('\uE30B', 'K') // Unown K
      .replaceAll('\uE30C', 'L') // Unown L
      .replaceAll('\uE30D', 'M') // Unown M
      .replaceAll('\uE30E', 'N') // Unown N
      .replaceAll('\uE30F', 'O') // Unown O
      .replaceAll('\uE310', 'P') // Unown P
      .replaceAll('\uE311', 'Q') // Unown Q
      .replaceAll('\uE312', 'R') // Unown R
      .replaceAll('\uE313', 'S') // Unown S
      .replaceAll('\uE314', 'T') // Unown T
      .replaceAll('\uE315', 'U') // Unown U
      .replaceAll('\uE316', 'V') // Unown V
      .replaceAll('\uE317', 'W') // Unown W
      .replaceAll('\uE318', 'X') // Unown X
      .replaceAll('\uE319', 'Y') // Unown Y
      .replaceAll('\uE31A', 'Z') // Unown Z
      .replaceAll('\uE31B', '!') // Unown !
      .replaceAll('\uE31C', '?') // Unown ?
    );
  }

  /**
   * Appends additional metadata to each string:
   * - For strings with ruby, appends copies of the strings with the ruby text converted to kana/kanji so that they can be searched.
   *   These copies are separated by `U+F0000` and `U+F0001` so that they can be stripped before display.
   *
   * Returns the resulting string.
   */
  const preprocessMetadata = (s: string) => {
    return s.search(/\{[^|}]+\|[^|}]+\}/u) === -1 ? s : (
      s.replaceAll(/^.*\{[^|}]+\|[^|}]+\}.*$/gum, (line) => {
        const lineKanji = line.replaceAll(/\{([^|}]+)\|[^|}]+\}/gu, '$1');
        const lineKana = line.replaceAll(/\{[^|}]+\|([^|}]+)\}/gu, '$1');
        return [line, '\u{F0000}', lineKanji, '\u{F0001}', lineKana].join('');
      })
    );
  }

  /**
   * Converts private use characters to the corresponding Unicode characters,
   * and adds additional searchable metadata.
   *
   * Returns the resulting string.
   */
  const preprocessString = (s: string) => {
    return preprocessMetadata(remapSwitchSpecialCharacters(remap3DSSpecialCharacters(remapNDSSpecialCharacters(s))));
  }

  /**
   * Strips additional metadata from each string:
   * - Converted ruby text marked with `U+F0000` and `U+F0001`
   *
   * Returns the resulting string.
   */
  const postprocessMetadata = (s: string) => {
    return s.split('\u{F0000}')[0];
  }

  /**
   * Converts the provided string to HTML by escaping `<` and `>`,
   * replacing line break control characters such as  `\n` with `<br>`,
   * and converting the ruby syntax `{base|ruby}` to the corresponding HTML tags.
   *
   * Returns the resulting HTML string.
   */
  const postprocessString = (s: string) => {
    return (postprocessMetadata(s)
      .replaceAll('<', '&lt;').replaceAll('>', '&gt;')
      .replaceAll('\u2486', '<sup>P</sup><sub>K</sub>') // Gen 5 PK
      .replaceAll('\u2487', '<sup>M</sup><sub>N</sub>') // Gen 5 MN
      .replaceAll('\uE0A7', '<sup>P</sup><sub>K</sub>') // 3DS PK
      .replaceAll('\uE0A8', '<sup>M</sup><sub>N</sub>') // 3DS MN
      .replaceAll(/\[VAR FF01\(FF43\)\]\[VAR FF01\(30B3\)\]/gu, '')
      .replaceAll(/\[VAR FF01\(FF43\)\](.+?)(?:\[VAR FF01\(30B3\)\]|\\r|\\c|\\n|$)/gu, '<span class="line-font-size-200"><span class="text-font-size-200">$1</span></span>')
      .replaceAll('[VAR FF01(30B3)]', '')
      .replaceAll(/\[VAR 0205\](.*?(?:\\r|\\c|\\n|$)+)/gu, '<span class="line-align-center">$1</span>')
      .replaceAll(/\[VAR 0206\](.*?(?:\\r|\\c|\\n|$)+)/gu, '<span class="line-align-right">$1</span>')

      // Line breaks
      .replaceAll('[VAR 0207]\\n', '<span class="c">&#91;VAR 0207&#93;</span><span class="n">&#92;n</span><br>')
      .replaceAll('[VAR 0208]\\n', '<span class="r">&#91;VAR 0208&#93;</span><span class="n">&#92;n</span><br>')
      .replaceAll('\\r\\n', '<span class="r">&#92;r</span><span class="n">&#92;n</span><br>')
      .replaceAll('\\c\\n', '<span class="c">&#92;c</span><span class="n">&#92;n</span><br>')
      .replaceAll('[VAR 0207]', '<span class="c">[VAR 0207]</span>')
      .replaceAll('[VAR 0208]', '<span class="r">[VAR 0208]</span>')
      .replaceAll('\\r', '<span class="r">&#92;r</span><br>')
      .replaceAll('\\c', '<span class="c">&#92;c</span><br>')
      .replaceAll('\\n', '<span class="n">&#92;n</span><br>')

      .replaceAll('\t', '<span class="tab">\t</span>')
      .replaceAll('[NULL]', '<span class="null">[NULL]</span>')
      .replaceAll('[COMP]', '<span class="compressed">[COMP]</span>')
      .replaceAll(/(\[VAR [^\]]+?\])/gu, '<span class="var">$1</span>')
      .replaceAll(/(\[WAIT \d+\])/gu, '<span class="wait">$1</span>')
      .replaceAll(/(\[~ \d+\])/gu, '<span class="unused">$1</span>')
      .replaceAll(/\{([^|}]+)\|([^|}]+)\}/gu, '<ruby>$1<rp>(</rp><rt>$2</rt><rp>)</rp></ruby>') // Switch furigana
      .replaceAll(/^(\s+)$/gu, '<span class="whitespace">$1</span>')
    );
  };
  //#endregion

  const {index, params, collectionKey, fileKey, languages} = task.data;
  const notify = (status: SearchTaskResultStatus, result?: SearchTaskResultLines) => {
    const message: SearchTaskResult = {
      index: index,
      status: status,
      result: result
    }
    postMessage(message);
  }

  let re: RegExp | null = null;
  try {
    if (params.regex) {
      re = new RegExp(params.query, params.caseInsensitive ? 'ui' : 'u');
    }
  }
  catch (err) {
    console.error(err);
    notify('regex');
    return;
  }

  const matchCondition = (line: string): boolean => {
    return (params.regex && re !== null && line.match(re) !== null)
      || (!params.regex && !params.caseInsensitive && line.includes(params.query))
      || (!params.regex && params.caseInsensitive && (line.toLowerCase().includes(params.query.toLowerCase()) || line.toUpperCase().includes(params.query.toUpperCase())));
  };

  try {
    // Load files
    const filePromises = languages.map((languageKey) => getFileFromCache(collectionKey, languageKey, fileKey).then((data) => [languageKey, data] as [string, string]));
    filePromises.forEach((promise) => promise.then(() => notify('loading')).catch(() => {})); // for progress bar

    // Process files
    const processingFilePromises = filePromises.map((promise) => promise.then(([languageKey, data]) => {
      const lines = data.split(/\r\n|\n/);
      const lineKeys: number[] = [];

      // Check selected languages for lines that satisfy the query
      if (params.languages.includes(languageKey)) {
        lines.forEach((line, i) => {
          if (matchCondition(line)) {
            lineKeys.push(i);
          }
        });
      }
      return [languageKey, lineKeys, lines] as [string, number[], string[]];
    }));
    processingFilePromises.forEach((promise) => promise.then(() => notify('processing')).catch(() => {})); // for progress bar

    // Filter only the lines that matched
    Promise.all(processingFilePromises).then((processedFiles) => {
      const languageKeys: string[] = [];
      const lineKeysSet: Set<number> = new Set();
      const fileData: string[][] = [];

      processedFiles.forEach(([languageKey, lineKeys, lines]) => {
        languageKeys.push(languageKey);
        lineKeys.forEach((i) => lineKeysSet.add(i));
        fileData.push(lines);
      });

      const fileResults: string[][] = [];
      Array.from(lineKeysSet).sort((a, b) => a - b).forEach((i) => fileResults.push(fileData.map((lines) => postprocessString(lines[i] ?? ''))));
      notify('done', {
        collection: collectionKey,
        file: fileKey,
        languages: languageKeys,
        lines: fileResults,
      });
    })
    .catch((err) => {
      console.error(err);
      notify('error');
    });
  }
  catch (err) {
    console.error(err);
    notify('error');
  }
};
